<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Japanese Conjugation Practice</title>
        <style>
            :root {
				--primary: #4a6fa5;
				--primary-light: #6989bc;
				--secondary: #47b8e0;
				--accent: #ff6b6b;
				--dark: #252c37;
				--light: #f5f7fa;
				--success: #4caf50;
				--warning: #ff9800;
				--danger: #f44336;
                --gray-100: #f8f9fa;
                --gray-200: #e9ecef;
                --gray-300: #dee2e6;
                --gray-400: #ced4da;
                --gray-500: #adb5bd;
                --gray-600: #6c757d;
                --gray-700: #495057;
                --gray-800: #343a40;
                --radius: 0.5rem;
				--font-sans: "Inter", "Segoe UI", Roboto, "Helvetica Neue",
					sans-serif;
                --ring-color: rgba(74, 111, 165, 0.3);
            }
            html {
                overflow: hidden;
                height: 100%;
            }
            body {
                overflow: auto;
                height: 100%;
                font-family: var(--font-sans);
                margin: 0;
                padding: 0;
				background: linear-gradient(
					to right,
					var(--primary),
					var(--secondary)
				);
                color: var(--dark);
                line-height: 1.6;
                font-size: 16px;
                min-height: 100vh;
            }
            .container {
				max-width: 800px;
				margin: 2rem auto;
				padding: 2rem;
                background-color: var(--light);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
                border-radius: var(--radius);
            }
            h1 {
                text-align: center;
				margin-bottom: 2rem;
                color: var(--dark);
			}
            .card {
                background: white;
                border-radius: var(--radius);
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1),
					0 1px 2px rgba(0, 0, 0, 0.06);
				padding: 1.5rem;
				margin-bottom: 1.5rem;
                border: 1px solid var(--gray-200);
            }
			#quiz-area .verb-display {
				font-size: 2.5rem;
				font-weight: bold;
				text-align: center;
				margin-bottom: 0.5rem;
				color: var(--primary);
			}
			#quiz-area .form-display {
				font-size: 1.5rem;
				text-align: center;
				margin-bottom: 1.5rem;
                color: var(--gray-700);
            }
			#answer-input {
                width: 100%;
				padding: 1rem;
				font-size: 1.25rem;
				text-align: center;
                border: 1px solid var(--gray-300);
                border-radius: var(--radius);
				box-sizing: border-box;
                transition: all 0.15s ease;
            }
			#answer-input:focus {
                outline: none;
                border-color: var(--primary);
				box-shadow: 0 0 0 3px var(--ring-color);
			}
            .btn {
                background: var(--primary);
                color: white;
                border: none;
				padding: 0.75rem 1.5rem;
                border-radius: var(--radius);
                cursor: pointer;
                font-size: 1rem;
                font-weight: 500;
                transition: all 0.15s ease;
				display: block;
				width: 100%;
				margin-top: 1rem;
			}
            .btn:hover {
                background: var(--primary-light);
                transform: translateY(-1px);
			}
			#result-area {
				padding: 1rem;
				margin-top: 1rem;
                border-radius: var(--radius);
				text-align: center;
				font-size: 1.2rem;
				font-weight: 500;
			}
			.correct {
				background-color: #e8f5e9;
                color: var(--success);
				border: 1px solid var(--success);
			}
			.incorrect {
				background-color: #ffebee;
				color: var(--danger);
				border: 1px solid var(--danger);
			}
			#settings-area .settings-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
				gap: 0.5rem;
			}
			.checkbox-group {
				display: flex;
				align-items: center;
			}
			.checkbox-group input {
				margin-right: 0.5rem;
			}
			footer {
				text-align: center;
				margin-top: 2rem;
				color: var(--light);
				font-size: 0.8rem;
			}
			footer a {
				color: var(--light);
				text-decoration: underline;
            }
        </style>
    </head>
    <body>
        <div class="container">
			<h1>Japanese Conjugation Practice</h1>

			<div id="quiz-area" class="card">
				<div id="verb-display" class="verb-display">Loading verbs...</div>
				<div id="form-display" class="form-display">Please wait.</div>
				<form id="answer-form">
					<input
						type="text"
						id="answer-input"
						placeholder="Type your answer in hiragana"
						autocomplete="off"
						autofocus
					/>
					<button type="submit" class="btn">Check Answer</button>
				</form>
                    </div>
                    
			<div id="result-area" style="display: none"></div>

			<div id="settings-area" class="card">
				<h2>Settings</h2>
				<div id="conjugation-forms" class="settings-grid">
					<!-- Checkboxes will be inserted here by script -->
                </div>
            </div>
            </div>
            
		<footer>
			<p>
				This site uses the JMdict dictionary file. This file is the property
				of the
				<a
					href="https://www.edrdg.org/"
					target="_blank"
					rel="noopener noreferrer"
					>Electronic Dictionary Research and Development Group</a
				>, and is used in conformance with the Group's
				<a
					href="https://www.edrdg.org/wiki/index.php/Main_Page#Licence_Statement"
					target="_blank"
					rel="noopener noreferrer"
					>licence</a
				>.
			</p>
		</footer>

        <script>
			// --- DOM Elements ---
			const verbDisplay = document.getElementById("verb-display");
			const formDisplay = document.getElementById("form-display");
			const answerInput = document.getElementById("answer-input");
			const answerForm = document.getElementById("answer-form");
			const resultArea = document.getElementById("result-area");
			const settingsContainer = document.getElementById("conjugation-forms");

			// --- State ---
			let verbs = [];
			let currentQuestion = null;
			const conjugationForms = {
				polite: "Polite (e.g., 'I do')",
				past: "Past (e.g., 'I did')",
				te: "Te-form (for connecting verbs)",
				negative: "Negative (e.g., 'I don't do')",
				potential: "Potential (e.g., 'I can do')",
				passive: "Passive (e.g., 'is done')",
				causative: "Causative (e.g., 'to make someone do')",
				provisional: "Provisional (e.g., 'if I do')",
				imperative: "Imperative (e.g., 'Do it!')",
				volitional: "Volitional (e.g., 'Let's do')",
			};
			let activeForms = Object.keys(conjugationForms);

			// --- Initialization ---
			document.addEventListener("DOMContentLoaded", async () => {
				renderSettings();
				await loadVerbs();
				if (verbs.length > 0) {
					generateNewQuestion();
				} else {
					verbDisplay.textContent = "Error";
					formDisplay.innerHTML = `
						Could not load verbs from JMdict_e.xml.
						<br>
						<small style="font-size: 0.9rem; color: var(--gray-600);">
							Please open the browser's developer console for details.
							(Usually F12, or Cmd/Ctrl+Shift+I)
						</small>
					`;
				}
			});

			answerForm.addEventListener("submit", (e) => {
				e.preventDefault();
				checkAnswer();
			});

			// --- Verbs Loading and Parsing ---
			async function loadVerbs() {
				const verbPOSTags = [
                    'v1', 'v2a-s', 'v4h', 'v4r', 'v5', 'v5aru', 'v5b', 'v5g', 'v5k', 'v5k-s',
                    'v5m', 'v5n', 'v5r', 'v5r-i', 'v5s', 'v5t', 'v5u', 'v5u-s', 'v5uru', 'v5z',
                    'vz', 'vi', 'vk', 'vn', 'vr', 'vs', 'vs-s', 'vs-i', 'vt', 'aux-v'
                ];

				try {
					console.log("Attempting to fetch JMdict_e.xml...");
					const response = await fetch("JMdict_e.xml");
					console.log(`Fetch response status: ${response.status}`);
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					const xmlText = await response.text();
					console.log(`XML file loaded (${(xmlText.length / 1024 / 1024).toFixed(2)} MB). Starting pre-processing...`);

					// Pre-process the XML text to replace entities, which DOMParser doesn't handle.
					let processedXmlText = xmlText.replace(/&/g, '&amp;'); // Escape existing ampersands first
					for (const tag of verbPOSTags) {
						const entityRegex = new RegExp(`&amp;${tag};`, 'g');
						processedXmlText = processedXmlText.replace(entityRegex, tag);
					}
					// A general fallback for any other entities we didn't list, to prevent parsing errors.
					processedXmlText = processedXmlText.replace(/&amp;([a-z0-9-]+);/g, '$1');
					console.log("XML pre-processing complete. Starting parse...");

					const parser = new DOMParser();
					const xmlDoc = parser.parseFromString(processedXmlText, "text/xml");

					const parserError = xmlDoc.querySelector("parsererror");
					if (parserError) {
						console.error("XML parsing error:", parserError.textContent);
						throw new Error("Failed to parse the XML file.");
					}

					const entries = xmlDoc.getElementsByTagName("entry");
					console.log(`Found ${entries.length} total <entry> elements.`);
                    let processedVerbs = 0;

					for (const entry of entries) {
						const senses = entry.getElementsByTagName("sense");
						for (const sense of senses) {
							const posElements = sense.getElementsByTagName("pos");
							const posTags = Array.from(posElements).map(p => p.textContent);

							const foundVerbTags = posTags.filter(pt => verbPOSTags.includes(pt));

							if (foundVerbTags.length > 0) {
								const kebElements = entry.getElementsByTagName("k_ele");
								const rebElements = entry.getElementsByTagName("r_ele");
								const glossElement = sense.querySelector("gloss");

								if (rebElements.length > 0 && glossElement) {
									const reading = rebElements[0].querySelector("reb").textContent;
									const kanji = kebElements.length > 0 ? kebElements[0].querySelector("keb").textContent : reading;
									const verbType = getVerbType(foundVerbTags, reading);

									if (verbType) {
                                        if (processedVerbs < 10) { // Log the first 10 verbs we successfully classify
                                            console.log(`SUCCESS: Classified [${kanji}/${reading}] as [${verbType}] with tags:`, foundVerbTags);
                                        }
										verbs.push({
											kanji: kanji,
											reading: reading,
											english: glossElement.textContent.split(';')[0],
											type: verbType,
											dictForm: kanji || reading,
										});
                                        processedVerbs++;
										break; 
									}
								}
							}
						}
					}
					console.log(`--- PARSING COMPLETE ---`);
                    console.log(`Found and successfully classified ${verbs.length} verbs.`);
					if (verbs.length > 0) {
						console.log("First verb found:", verbs[0]);
					} else {
						console.warn("Parsing finished, but no verbs were added. This indicates an issue with the getVerbType logic or XML structure not matching expectations.");
					}
				} catch (error) {
					console.error("Fatal error in loadVerbs:", error);
                    verbDisplay.textContent = "Fatal Error";
                    formDisplay.innerHTML = `An error occurred while loading verbs. <br><small>${error.message}</small>`;
				}
			}

			function getVerbType(posTags, reading) {
				if (!reading) {
                    console.warn("Skipping verb because it has no reading:", posTags);
                    return null;
                }

				if (posTags.includes("v1") || posTags.includes("vz")) return "ichidan";
				
				if (posTags.some(p => p && p.startsWith("v5"))) {
					const ending = reading.slice(-1);
					if ("うくぐすつぬぶむる".includes(ending)) {
						return `godan-${ending}`;
					} else {
                        console.warn(`Found godan verb with unhandled ending '${ending}'`, {reading, posTags});
                        return null; // Don't classify if ending is not standard
                    }
				}
				
				if (posTags.some(p => p && p.startsWith("vs"))) return "suru";
				if (posTags.includes("vk")) return "kuru";

                // This is not an error, just a verb type we don't handle (e.g. aux-v)
				return null;
			}

			// --- Settings ---
			function renderSettings() {
				settingsContainer.innerHTML = "";
				for (const [key, value] of Object.entries(conjugationForms)) {
					const div = document.createElement("div");
					div.className = "checkbox-group";
					const checkbox = document.createElement("input");
					checkbox.type = "checkbox";
					checkbox.id = `check-${key}`;
					checkbox.value = key;
					checkbox.checked = true;
					checkbox.addEventListener("change", updateActiveForms);
					const label = document.createElement("label");
					label.htmlFor = `check-${key}`;
					label.textContent = value;
					div.appendChild(checkbox);
					div.appendChild(label);
					settingsContainer.appendChild(div);
				}
			}

			function updateActiveForms() {
				activeForms = Array.from(
					settingsContainer.querySelectorAll("input:checked"),
				).map((cb) => cb.value);
				if (activeForms.length === 0) {
					// Fallback to all forms if none are selected
					activeForms = Object.keys(conjugationForms);
				}
			}

			// --- Quiz Logic ---
			function generateNewQuestion() {
				resultArea.style.display = "none";
				answerInput.value = "";
				answerInput.focus();

				const randomVerb = verbs[Math.floor(Math.random() * verbs.length)];
				const randomFormKey =
					activeForms[Math.floor(Math.random() * activeForms.length)];

				currentQuestion = {
					verb: randomVerb,
					form: randomFormKey,
					answer: conjugate(randomVerb, randomFormKey),
				};

				verbDisplay.textContent = `${randomVerb.dictForm} (${randomVerb.english})`;
				formDisplay.textContent = conjugationForms[randomFormKey];
			}

			function checkAnswer() {
				const userAnswer = answerInput.value.trim();
				if (!userAnswer) return;

				resultArea.style.display = "block";
				if (userAnswer === currentQuestion.answer) {
					resultArea.textContent = `Correct!`;
					resultArea.className = "correct";
                } else {
					resultArea.innerHTML = `Incorrect. The correct answer is: <strong>${currentQuestion.answer}</strong>`;
					resultArea.className = "incorrect";
				}
				setTimeout(generateNewQuestion, 2000);
			}

			// --- Conjugation Engine ---
			function conjugate(verb, form) {
				const { type, reading } = verb;
				if (!reading) return verb.dictForm;

				if (type === "suru") {
					// Use kanji stem if it exists and makes sense, otherwise it's just a loan word + suru
					const base = verb.kanji.endsWith('する') ? verb.kanji.replace(/する$/, "") : verb.dictForm.replace(/する$/, "");
					switch (form) {
						case "polite": return base + "します";
						case "past": return base + "した";
						case "te": return base + "して";
						case "negative": return base + "しない";
						case "potential": return base + "できる";
						case "passive": return base + "される";
						case "causative": return base + "させる";
						case "provisional": return base + "すれば";
						case "imperative": return base + "しろ"; // or せよ
						case "volitional": return base + "しよう";
						default: return verb.dictForm;
					}
				}

				if (type === "kuru") {
					const base = verb.kanji === '来る' ? '来' : '';
					if(base) {
						switch (form) {
							case "polite": return base + "ます"; // きます
							case "past": return base + "た"; // きた
							case "te": return base + "て"; // きて
							case "negative": return "こない";
							case "potential": return "こられる";
							case "passive": return "こられる";
							case "causative": return "こさせる";
							case "provisional": return "くれば";
							case "imperative": return "こい";
							case "volitional": return "こよう";
							default: return verb.dictForm;
						}
					}
					// fallback to kana if no kanji base
					switch (form) {
						case "polite": return "きます";
						case "past": return "きた";
						case "te": return "きて";
						case "negative": return "こない";
						case "potential": return "こられる";
						case "passive": return "こられる";
						case "causative": return "こさせる";
						case "provisional": return "くれば";
						case "imperative": return "こい";
						case "volitional": return "こよう";
						default: return verb.dictForm;
					}
				}

				if (type === "ichidan") {
					const base = verb.dictForm.slice(0, -1);
					switch (form) {
						case "polite": return base + "ます";
						case "past": return base + "た";
						case "te": return base + "て";
						case "negative": return base + "ない";
						case "potential": return base + "られる";
						case "passive": return base + "られる";
						case "causative": return base + "させる";
						case "provisional": return base + "れば";
						case "imperative": return base + "ろ"; // or よ
						case "volitional": return base + "よう";
						default: return verb.dictForm;
					}
				}

				if (type.startsWith("godan")) {
					const ending = type.split("-")[1];
					const base = verb.dictForm.slice(0, -1);
					const endings = {
						u: { a: "わ", i: "い", e: "え", o: "お", te: "って", ta: "った" },
						ku: { a: "か", i: "き", e: "け", o: "こ", te: "いて", ta: "いた" },
						gu: { a: "が", i: "ぎ", e: "げ", o: "ご", te: "いで", ta: "いだ" },
						su: { a: "さ", i: "し", e: "せ", o: "そ", te: "して", ta: "した" },
						tsu: { a: "た", i: "ち", e: "て", o: "と", te: "って", ta: "った" },
						nu: { a: "な", i: "に", e: "ね", o: "の", te: "んで", ta: "んだ" },
						bu: { a: "ば", i: "び", e: "べ", o: "ぼ", te: "んで", ta: "んだ" },
						mu: { a: "ま", i: "み", e: "め", o: "も", te: "んで", ta: "んだ" },
						ru: { a: "ら", i: "り", e: "れ", o: "ろ", te: "って", ta: "った" },
					};
					// special case for 行く
					if (verb.reading === 'いく' && (form === 'te' || form === 'past')) {
						return base + (form === 'te' ? 'って' : 'った');
					}
					
					const e = endings[ending];
					if (!e) return verb.dictForm; // Should not happen

					switch (form) {
						case "polite": return base + e.i + "ます";
						case "past": return base + e.ta;
						case "te": return base + e.te;
						case "negative": return base + e.a + "ない";
						case "potential": return base + e.e + "る";
						case "passive": return base + e.a + "れる";
						case "causative": return base + e.a + "せる";
						case "provisional": return base + e.e + "ば";
						case "imperative": return base + e.e;
						case "volitional": return base + e.o + "う";
						default: return verb.dictForm;
					}
				}
				
				return verb.dictForm; // Fallback
			}
        </script>
    </body>
</html>
