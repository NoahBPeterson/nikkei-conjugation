<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Japanese Conjugation Practice</title>
        <style>
            :root {
				--primary: #4a6fa5;
				--primary-light: #6989bc;
				--secondary: #47b8e0;
				--accent: #ff6b6b;
				--dark: #252c37;
				--light: #f5f7fa;
				--success: #4caf50;
				--warning: #ff9800;
				--danger: #f44336;
                --gray-100: #f8f9fa;
                --gray-200: #e9ecef;
                --gray-300: #dee2e6;
                --gray-400: #ced4da;
                --gray-500: #adb5bd;
                --gray-600: #6c757d;
                --gray-700: #495057;
                --gray-800: #343a40;
                --radius: 0.5rem;
				--font-sans: "Inter", "Segoe UI", Roboto, "Helvetica Neue",
					sans-serif;
                --ring-color: rgba(74, 111, 165, 0.3);
            }
            html {
                overflow: hidden;
                height: 100%;
            }
            body {
                overflow: auto;
                height: 100%;
                font-family: var(--font-sans);
                margin: 0;
                padding: 0;
				background: linear-gradient(
					to right,
					var(--primary),
					var(--secondary)
				);
                color: var(--dark);
                line-height: 1.6;
                font-size: 16px;
                min-height: 100vh;
            }
            .container {
				max-width: 800px;
				margin: 2rem auto;
				padding: 2rem;
                background-color: var(--light);
                box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
                border-radius: var(--radius);
            }
            h1 {
                text-align: center;
				margin-bottom: 2rem;
                color: var(--dark);
			}
            .card {
                background: white;
                border-radius: var(--radius);
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1),
					0 1px 2px rgba(0, 0, 0, 0.06);
				padding: 1.5rem;
				margin-bottom: 1.5rem;
                border: 1px solid var(--gray-200);
            }
			#quiz-area .verb-display {
				font-size: 2.5rem;
				font-weight: bold;
				text-align: center;
				margin-bottom: 0.5rem;
				color: var(--primary);
			}
			.furigana {
				font-size: 1rem;
				color: var(--gray-600);
				font-weight: normal;
				display: block;
				margin-bottom: 0.25rem;
			}
			.verb-with-furigana {
				position: relative;
			}
			#quiz-area .form-display {
				font-size: 1.5rem;
				text-align: center;
				margin-bottom: 1.5rem;
                color: var(--gray-700);
            }
			#answer-input {
                width: 100%;
				padding: 1rem;
				font-size: 1.25rem;
				text-align: center;
                border: 1px solid var(--gray-300);
                border-radius: var(--radius);
				box-sizing: border-box;
                transition: all 0.15s ease;
            }
			#answer-input:focus {
                outline: none;
                border-color: var(--primary);
				box-shadow: 0 0 0 3px var(--ring-color);
			}
            .btn {
                background: var(--primary);
                color: white;
                border: none;
				padding: 0.75rem 1.5rem;
                border-radius: var(--radius);
                cursor: pointer;
                font-size: 1rem;
                font-weight: 500;
                transition: all 0.15s ease;
				display: block;
				width: 100%;
				margin-top: 1rem;
			}
            .btn:hover {
                background: var(--primary-light);
                transform: translateY(-1px);
			}
			#result-area {
				padding: 1rem;
				margin-top: 1rem;
                border-radius: var(--radius);
				text-align: center;
				font-size: 1.2rem;
				font-weight: 500;
			}
			.correct {
				background-color: #e8f5e9;
                color: var(--success);
				border: 1px solid var(--success);
			}
			.incorrect {
				background-color: #ffebee;
				color: var(--danger);
				border: 1px solid var(--danger);
			}
			#settings-area .settings-grid {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
				gap: 0.5rem;
			}
			.checkbox-group {
				display: flex;
				align-items: center;
			}
			.checkbox-group input {
				margin-right: 0.5rem;
			}
			footer {
				text-align: center;
				margin-top: 2rem;
				color: var(--light);
				font-size: 0.8rem;
			}
			footer a {
				color: var(--light);
				text-decoration: underline;
            }
        </style>
    </head>
    <body>
        <div class="container">
			<h1>Japanese Conjugation Practice</h1>

			<div id="quiz-area" class="card">
				<div id="verb-display" class="verb-display">Loading verbs...</div>
				<div id="form-display" class="form-display">Please wait.</div>
				<form id="answer-form">
					<input
						type="text"
						id="answer-input"
						placeholder="Type your answer in hiragana"
						autocomplete="off"
						autofocus
					/>
					<button type="submit" class="btn">Check Answer</button>
				</form>
                    </div>
                    
			<div id="result-area" style="display: none"></div>

			<div id="settings-area" class="card">
				<h2>Settings</h2>
				<div id="conjugation-forms" class="settings-grid">
					<!-- Checkboxes will be inserted here by script -->
                </div>
				<div style="margin-top: 1rem; border-top: 1px solid var(--gray-200); padding-top: 1rem;">
					<div class="checkbox-group">
						<input type="checkbox" id="english-prompt-mode">
						<label for="english-prompt-mode"><strong>English Prompt Mode</strong> (Guess from English)</label>
					</div>
					<div class="checkbox-group" style="margin-top: 0.5rem;">
						<input type="checkbox" id="include-uncommon-verbs">
						<label for="include-uncommon-verbs">Include less common verbs</label>
					</div>
					<div class="checkbox-group" style="margin-top: 0.5rem;">
						<input type="checkbox" id="include-suru-verbs">
						<label for="include-suru-verbs">Include 'suru' verbs</label>
					</div>
					<div class="checkbox-group" style="margin-top: 0.5rem;">
						<input type="checkbox" id="show-translation" checked>
						<label for="show-translation">Show English translation</label>
					</div>
					<div class="checkbox-group" style="margin-top: 0.5rem;">
						<input type="checkbox" id="show-furigana">
						<label for="show-furigana">Show furigana <em style="color: var(--gray-600); font-size: 0.9em;">(Shift)</em></label>
					</div>
					<div class="checkbox-group" style="margin-top: 0.5rem;">
						<input type="checkbox" id="use-conjugated-english">
						<label for="use-conjugated-english">Use conjugated English prompts</label>
					</div>
				</div>
			</div>
            </div>
            
		<footer>
			<p>
				This site uses the JMdict dictionary file. This file is the property
				of the
				<a
					href="https://www.edrdg.org/"
					target="_blank"
					rel="noopener noreferrer"
					>Electronic Dictionary Research and Development Group</a
				>, and is used in conformance with the Group's
				<a
					href="https://www.edrdg.org/wiki/index.php/Main_Page#Licence_Statement"
					target="_blank"
					rel="noopener noreferrer"
					>licence</a
				>.
			</p>
		</footer>

		<script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
		<script src="https://unpkg.com/wanakana"></script>
		<script>
			// --- DOM Elements ---
			const verbDisplay = document.getElementById("verb-display");
			const formDisplay = document.getElementById("form-display");
			const answerInput = document.getElementById("answer-input");
			const answerForm = document.getElementById("answer-form");
			const resultArea = document.getElementById("result-area");
			const settingsContainer = document.getElementById("conjugation-forms");
			const submitButton = document.querySelector("#answer-form button");

			// --- State ---
			let verbs = [];
			let currentQuestion = null;
			let isEnglishPromptMode = false;
			let includeUncommonVerbs = false;
			let includeSuruVerbs = false;
			let showTranslation = true;
			let showFurigana = false;
			let useConjugatedEnglish = false;
			let isAnswered = false;

			const conjugationForms = {
				polite: "Polite (e.g., 'I do')",
				past: "Past (e.g., 'I did')",
				te: "Te-form (for connecting verbs)",
				negative: "Negative (e.g., 'I don't do')",
				potential: "Potential (e.g., 'I can do')",
				passive: "Passive (e.g., 'is done')",
				causative: "Causative (e.g., 'to make someone do')",
				causativePassive: "Causative-Passive (e.g., 'is made to do')",
				provisional: "Provisional (e.g., 'if I do')",
				imperative: "Imperative (e.g., 'Do it!')",
				volitional: "Volitional (e.g., 'Let's do')",
			};
			let activeForms = Object.keys(conjugationForms);

			// --- Initialization ---
			document.addEventListener("DOMContentLoaded", async () => {
				renderSettings();
				wanakana.bind(document.getElementById("answer-input"));

				const englishPromptCheckbox = document.getElementById("english-prompt-mode");
				englishPromptCheckbox.addEventListener("change", (e) => {
					isEnglishPromptMode = e.target.checked;
					generateNewQuestion();
				});

				const uncommonVerbsCheckbox = document.getElementById("include-uncommon-verbs");
				uncommonVerbsCheckbox.addEventListener("change", (e) => {
					includeUncommonVerbs = e.target.checked;
					generateNewQuestion();
				});

				const suruVerbsCheckbox = document.getElementById("include-suru-verbs");
				suruVerbsCheckbox.addEventListener("change", (e) => {
					includeSuruVerbs = e.target.checked;
					generateNewQuestion();
				});

				const showTranslationCheckbox = document.getElementById("show-translation");
				showTranslationCheckbox.addEventListener("change", (e) => {
					showTranslation = e.target.checked;
					updateCurrentQuestionDisplay();
				});

				const showFuriganaCheckbox = document.getElementById("show-furigana");
				showFuriganaCheckbox.addEventListener("change", (e) => {
					showFurigana = e.target.checked;
					updateCurrentQuestionDisplay();
				});

				const useConjugatedEnglishCheckbox = document.getElementById("use-conjugated-english");
				useConjugatedEnglishCheckbox.addEventListener("change", (e) => {
					useConjugatedEnglish = e.target.checked;
					updateCurrentQuestionDisplay();
				});

				await loadVerbs();
				if (verbs.length > 0) {
					generateNewQuestion();
				} else {
					verbDisplay.textContent = "Error";
					formDisplay.innerHTML = `Could not load verb data. <br><small>Did you run the build script successfully?</small>`;
				}
			});

			answerForm.addEventListener("submit", (e) => {
				e.preventDefault();
				if (isAnswered) {
					generateNewQuestion();
				} else {
					checkAnswer();
				}
			});

			// Keyboard shortcuts
			document.addEventListener("keydown", (e) => {
				// Shift key to toggle furigana
				if (e.key === "Shift" && !e.ctrlKey && !e.metaKey && !e.altKey) {
					e.preventDefault();
					const furiganaCheckbox = document.getElementById("show-furigana");
					furiganaCheckbox.checked = !furiganaCheckbox.checked;
					showFurigana = furiganaCheckbox.checked;
					updateCurrentQuestionDisplay();
				}
			});

			// --- Verbs Loading and Parsing ---
			async function loadVerbs() {
				try {
					console.log("Attempting to fetch verbs.json.gz...");
					const response = await fetch("verbs.json.gz");
					if (!response.ok) {
						throw new Error(`HTTP error! status: ${response.status}`);
					}
					
					const compressedData = await response.arrayBuffer();
					console.log(`Fetched compressed data (${(compressedData.byteLength / 1024).toFixed(2)} KB). Decompressing...`);
					
					const decompressed = pako.inflate(compressedData, { to: 'string' });
					verbs = JSON.parse(decompressed);

					console.log(`Successfully loaded and decompressed ${verbs.length} verbs.`);
				} catch (error) {
					console.error("Fatal error loading verbs.json.gz:", error);
                    verbDisplay.textContent = "Fatal Error";
                    formDisplay.innerHTML = `Could not load verb data. <br><small>Did you run the build script successfully?</small>`;
				}
			}

			// --- Settings ---
			function renderSettings() {
				settingsContainer.innerHTML = "";
				for (const [key, value] of Object.entries(conjugationForms)) {
					const div = document.createElement("div");
					div.className = "checkbox-group";
					const checkbox = document.createElement("input");
					checkbox.type = "checkbox";
					checkbox.id = `check-${key}`;
					checkbox.value = key;
					checkbox.checked = true;
					checkbox.addEventListener("change", updateActiveForms);
					const label = document.createElement("label");
					label.htmlFor = `check-${key}`;
					label.textContent = value;
					div.appendChild(checkbox);
					div.appendChild(label);
					settingsContainer.appendChild(div);
				}
			}

			function updateActiveForms() {
				activeForms = Array.from(
					settingsContainer.querySelectorAll("input:checked"),
				).map((cb) => cb.value);
				if (activeForms.length === 0) {
					// Fallback to all forms if none are selected
					activeForms = Object.keys(conjugationForms);
				}
			}

			// --- Quiz Logic ---
			function generateNewQuestion() {
				let verbPool = verbs;
				
				if (!includeUncommonVerbs) {
					verbPool = verbPool.filter(v => v.common);
				}
				if (!includeSuruVerbs) {
					verbPool = verbPool.filter(v => v.type !== 'suru');
				}

				if (verbPool.length === 0) {
					verbDisplay.textContent = "No verbs found";
					formDisplay.innerHTML = `No verbs match the current filter settings. <br><small>Try changing the settings.</small>`;
					return;
				}

				resultArea.style.display = "none";
				answerInput.value = "";
				answerInput.focus();
				isAnswered = false;
				submitButton.textContent = "Check Answer";

				const randomVerb = verbPool[Math.floor(Math.random() * verbPool.length)];
				const randomFormKey =
					activeForms[Math.floor(Math.random() * activeForms.length)];
				
				const answer = conjugate(randomVerb, randomFormKey);

				currentQuestion = {
					verb: randomVerb,
					form: randomFormKey,
					answer: answer,
				};

				console.log("New question:", {
					verb: randomVerb.dictForm,
					english: randomVerb.english,
					type: randomVerb.type,
					form: randomFormKey,
					expectedAnswer: answer
				});

				if (isEnglishPromptMode) {
					// New mode: Show English verb, but also provide the dictionary form to remove ambiguity.
					if (useConjugatedEnglish) {
						const conjugatedEnglish = generateConjugatedEnglish(randomVerb.english, randomFormKey);
						verbDisplay.textContent = conjugatedEnglish;
						if (showFurigana && randomVerb.reading) {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span><br><span class="furigana">${randomVerb.reading}</span>`;
						} else {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span>`;
						}
					} else {
						verbDisplay.textContent = `${randomVerb.english.charAt(0).toUpperCase() + randomVerb.english.slice(1)}`;
						if (showFurigana && randomVerb.reading) {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span><br><span class="furigana">${randomVerb.reading}</span><br>${conjugationForms[randomFormKey]}`;
						} else {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span><br>${conjugationForms[randomFormKey]}`;
						}
					}
					answerInput.placeholder = "Type your answer in Japanese";
				} else {
					// Original mode: Show Japanese verb
					if (showFurigana && randomVerb.reading) {
						const furiganaHtml = `<span class="furigana">${randomVerb.reading}</span>`;
						if (showTranslation) {
							verbDisplay.innerHTML = `${furiganaHtml}${randomVerb.dictForm} (${randomVerb.english})`;
						} else {
							verbDisplay.innerHTML = `${furiganaHtml}${randomVerb.dictForm}`;
						}
					} else {
						if (showTranslation) {
							verbDisplay.textContent = `${randomVerb.dictForm} (${randomVerb.english})`;
						} else {
							verbDisplay.textContent = randomVerb.dictForm;
						}
					}
					formDisplay.textContent = conjugationForms[randomFormKey];
					answerInput.placeholder = "Type your answer in hiragana";
				}
			}

			function updateCurrentQuestionDisplay() {
				if (!currentQuestion) return;
				
				const { verb: randomVerb, form: randomFormKey } = currentQuestion;
				
				if (isEnglishPromptMode) {
					// New mode: Show English verb, but also provide the dictionary form to remove ambiguity.
					if (useConjugatedEnglish) {
						const conjugatedEnglish = generateConjugatedEnglish(randomVerb.english, randomFormKey);
						verbDisplay.textContent = conjugatedEnglish;
						if (showFurigana && randomVerb.reading) {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span><br><span class="furigana">${randomVerb.reading}</span>`;
						} else {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span>`;
						}
					} else {
						verbDisplay.textContent = `${randomVerb.english.charAt(0).toUpperCase() + randomVerb.english.slice(1)}`;
						if (showFurigana && randomVerb.reading) {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span><br><span class="furigana">${randomVerb.reading}</span><br>${conjugationForms[randomFormKey]}`;
						} else {
							formDisplay.innerHTML = `<span style="color: var(--gray-600); font-size: 1.2rem;">(${randomVerb.dictForm})</span><br>${conjugationForms[randomFormKey]}`;
						}
					}
				} else {
					// Original mode: Show Japanese verb
					if (showFurigana && randomVerb.reading) {
						const furiganaHtml = `<span class="furigana">${randomVerb.reading}</span>`;
						if (showTranslation) {
							verbDisplay.innerHTML = `${furiganaHtml}${randomVerb.dictForm} (${randomVerb.english})`;
						} else {
							verbDisplay.innerHTML = `${furiganaHtml}${randomVerb.dictForm}`;
						}
					} else {
						if (showTranslation) {
							verbDisplay.textContent = `${randomVerb.dictForm} (${randomVerb.english})`;
						} else {
							verbDisplay.textContent = randomVerb.dictForm;
						}
					}
				}
			}

			function checkAnswer() {
				const userAnswer = wanakana.toHiragana(answerInput.value.trim());
				if (!userAnswer) return;

				resultArea.style.display = "block";

				const answerWithKanji = currentQuestion.answer;
				
				// Create a hiragana-only version of the verb to generate the kana-only answer
				const hiraganaVerb = { ...currentQuestion.verb, dictForm: currentQuestion.verb.reading };
				const answerHiragana = conjugate(hiraganaVerb, currentQuestion.form);
				
				const isCorrect = (userAnswer === answerWithKanji || userAnswer === answerHiragana);

				if (isCorrect) {
					resultArea.textContent = `Correct!`;
					resultArea.className = "correct";
                } else {
					// Show the primary answer (with kanji, if available).
					resultArea.innerHTML = `Incorrect. The correct answer is: <strong>${answerWithKanji}</strong>`;
					resultArea.className = "incorrect";
				}
				isAnswered = true;
				submitButton.textContent = "Next Question";
			}

			// --- English Conjugation Generator ---
			function generateConjugatedEnglish(english, form) {
				// Remove "to " prefix if present
				const baseVerb = english.replace(/^to\s+/i, '');
				
				// Handle irregular verbs
				const irregularPast = {
					'go': 'went',
					'come': 'came',
					'do': 'did',
					'have': 'had',
					'be': 'was',
					'see': 'saw',
					'take': 'took',
					'give': 'gave',
					'make': 'made',
					'get': 'got',
					'know': 'knew',
					'think': 'thought',
					'say': 'said',
					'tell': 'told',
					'find': 'found',
					'buy': 'bought',
					'bring': 'brought',
					'teach': 'taught',
					'catch': 'caught',
					'fight': 'fought',
					'seek': 'sought'
				};
				
				const getPastForm = (verb) => {
					if (irregularPast[verb]) {
						return irregularPast[verb];
					}
					// Simple past tense rules
					if (verb.endsWith('e')) {
						return verb + 'd';
					} else if (verb.endsWith('y') && !/[aeiou]y$/.test(verb)) {
						return verb.slice(0, -1) + 'ied';
					} else if (/[^aeiou][aeiou][^aeiou]$/.test(verb)) {
						return verb + verb.slice(-1) + 'ed';
					} else {
						return verb + 'ed';
					}
				};
				
				switch (form) {
					case "polite":
						return `I ${baseVerb}`;
					case "past":
						return `I ${getPastForm(baseVerb)}`;
					case "te":
						return `...and ${baseVerb}`;
					case "negative":
						return `I don't ${baseVerb}`;
					case "potential":
						return `I can ${baseVerb}`;
					case "passive":
						return `is ${getPastForm(baseVerb)}`;
					case "causative":
						return `to make someone ${baseVerb}`;
					case "causativePassive":
						return `is made to ${baseVerb}`;
					case "provisional":
						return `if I ${baseVerb}`;
					case "imperative":
						return `${baseVerb.charAt(0).toUpperCase() + baseVerb.slice(1)}!`;
					case "volitional":
						return `let's ${baseVerb}`;
					default:
						return `to ${baseVerb}`;
				}
			}

			// --- Conjugation Engine ---
			function conjugate(verb, form) {
				const { type, reading, dictForm } = verb;
				if (!reading) return dictForm;

				if (type === "suru") {
					const base = dictForm.replace(/する$/, "");
					switch (form) {
						case "polite": return base + "します";
						case "past": return base + "した";
						case "te": return base + "して";
						case "negative": return base + "しない";
						case "potential": return base + "できる";
						case "passive": return base + "される";
						case "causative": return base + "させる";
						case "causativePassive": return base + "させられる";
						case "provisional": return base + "すれば";
						case "imperative": return base + "しろ";
						case "volitional": return base + "しよう";
						default: return dictForm;
					}
				}

				if (type === "kuru") {
					const base = dictForm === '来る' ? '来' : '';
					switch (form) {
						case "polite": return base ? base + "ます" : "きます";
						case "past": return base ? base + "た" : "きた";
						case "te": return base ? base + "て" : "きて";
						case "negative": return "こない";
						case "potential": return "こられる";
						case "passive": return "こられる";
						case "causative": return "こさせる";
						case "causativePassive": return "こさせられる";
						case "provisional": return "くれば";
						case "imperative": return "こい";
						case "volitional": return "こよう";
						default: return dictForm;
					}
				}

				if (type === 'godan-ru-special') {
					const base = dictForm.slice(0, -1);
					switch (form) {
						case 'polite':      return base + 'います'; // Irregular polite form
						case 'te':          return base + 'って';
						case 'past':        return base + 'った';
						case 'negative':    return base + 'らない';
						case 'provisional': return base + 'れば';
						case 'potential':   return base + 'れる';
						case 'passive':     return base + 'れる';
						case 'causative':   return base + 'させる';
						case 'causativePassive': return base + 'させられる';
						case 'imperative':  return base + 'い';
						case 'volitional':  return base + 'ろう';
						default: return dictForm;
					}
				}

				if (type === "ichidan") {
					const kanjiBase = dictForm.slice(0, -1);
					switch (form) {
						case "polite": return kanjiBase + "ます";
						case "past": return kanjiBase + "た";
						case "te": return kanjiBase + "て";
						case "negative": return kanjiBase + "ない";
						case "potential": return kanjiBase + "られる";
						case "passive": return kanjiBase + "られる";
						case "causative": return kanjiBase + "させる";
						case "causativePassive": return kanjiBase + "させられる";
						case "provisional": return kanjiBase + "れば";
						case "imperative": return kanjiBase + "ろ";
						case "volitional": return kanjiBase + "よう";
						default: return dictForm;
					}
				}

				if (type.startsWith("godan")) {
					const kanjiBase = dictForm.slice(0, -1);
					const ending = type.split("-")[1];
					const endings = {
						u: { a: "わ", i: "い", e: "え", o: "お", te: "って", ta: "った" },
						ku: { a: "か", i: "き", e: "け", o: "こ", te: "いて", ta: "いた" },
						gu: { a: "が", i: "ぎ", e: "げ", o: "ご", te: "いで", ta: "いだ" },
						su: { a: "さ", i: "し", e: "せ", o: "そ", te: "して", ta: "した" },
						tsu: { a: "た", i: "ち", e: "て", o: "と", te: "って", ta: "った" },
						nu: { a: "な", i: "に", e: "ね", o: "の", te: "んで", ta: "んだ" },
						bu: { a: "ば", i: "び", e: "べ", o: "ぼ", te: "んで", ta: "んだ" },
						mu: { a: "ま", i: "み", e: "め", o: "も", te: "んで", ta: "んだ" },
						ru: { a: "ら", i: "り", e: "れ", o: "ろ", te: "って", ta: "った" },
					};
					// special case for 行く
					if (reading === 'いく' && (form === 'te' || form === 'past')) {
						return kanjiBase + (form === 'te' ? 'って' : 'った');
					}
					
					const e = endings[ending];
					if (!e) return dictForm;

					switch (form) {
						case "polite": return kanjiBase + e.i + "ます";
						case "past": return kanjiBase + e.ta;
						case "te": return kanjiBase + e.te;
						case "negative": return kanjiBase + e.a + "ない";
						case "potential": return kanjiBase + e.e + "る";
						case "passive": return kanjiBase + e.a + "れる";
						case "causative": return kanjiBase + e.a + "せる";
						case "causativePassive": return kanjiBase + e.a + "せられる";
						case "provisional": return kanjiBase + e.e + "ば";
						case "imperative": return kanjiBase + e.e;
						case "volitional": return kanjiBase + e.o + "う";
						default: return dictForm;
					}
				}
				
				return dictForm; // Fallback
			}
        </script>
		<script>
			// --- Conjugation Test Suite ---
			function runConjugationTests() {
				console.log("--- Running Conjugation Test Suite ---");

				// Dummy 'conjugate' function to run tests without the full verb list.
				// This must be a copy of the main conjugate function.
				const conjugate = window.conjugate;

				const testCases = [
					// User's latest report
					{ verb: { dictForm: '居らっしゃる', reading: 'いらっしゃる', type: 'godan-ru-special' }, form: 'provisional', expected: '居らっしゃれば' },
					{ verb: { dictForm: 'いらっしゃる', reading: 'いらっしゃる', type: 'godan-ru-special' }, form: 'polite', expected: 'いらっしゃいます' },
					{ verb: { dictForm: '止む', reading: 'やむ', type: 'godan-mu' }, form: 'polite', expected: '止みます' },
					{ verb: { dictForm: '読む', reading: 'よむ', type: 'godan-mu' }, form: 'polite', expected: '読みます' },
					{ verb: { dictForm: '余る', reading: 'あまる', type: 'godan-ru' }, form: 'volitional', expected: '余ろう' },
					
					// From previous reports
					{ verb: { dictForm: '湿る', reading: 'しめる', type: 'godan-ru' }, form: 'provisional', expected: '湿れば' },
					{ verb: { dictForm: '降り積もる', reading: 'ふりつもる', type: 'godan-ru' }, form: 'te', expected: '降り積もって' },
					
					// Other regression and edge cases
					{ verb: { dictForm: '取る', reading: 'とる', type: 'godan-ru' }, form: 'volitional', expected: '取ろう' },
					{ verb: { dictForm: '歩く', reading: 'あるく', type: 'godan-ku' }, form: 'te', expected: '歩いて' },
					{ verb: { dictForm: '行く', reading: 'いく', type: 'godan-ku' }, form: 'te', expected: '行って' },
					{ verb: { dictForm: '食べる', reading: 'たべる', type: 'ichidan' }, form: 'past', expected: '食べた' },
					{ verb: { dictForm: 'する', reading: 'する', type: 'suru' }, form: 'negative', expected: 'しない' },
					{ verb: { dictForm: '来る', reading: 'くる', type: 'kuru' }, form: 'potential', expected: 'こられる' },
					{ verb: { dictForm: '買う', reading: 'かう', type: 'godan-u' }, form: 'volitional', expected: '買おう' },
					
					// Causative-passive tests
					{ verb: { dictForm: '食べる', reading: 'たべる', type: 'ichidan' }, form: 'causativePassive', expected: '食べさせられる' },
					{ verb: { dictForm: '読む', reading: 'よむ', type: 'godan-mu' }, form: 'causativePassive', expected: '読ませられる' },
					{ verb: { dictForm: 'する', reading: 'する', type: 'suru' }, form: 'causativePassive', expected: 'させられる' },
					{ verb: { dictForm: '来る', reading: 'くる', type: 'kuru' }, form: 'causativePassive', expected: 'こさせられる' },
				];

				let failures = 0;
				testCases.forEach(({ verb, form, expected }, i) => {
					const result = conjugate(verb, form);
					if (result === expected) {
						console.log(`%c[PASS] Test ${i+1}: ${verb.dictForm} (${form}) -> ${result}`, 'color: green');
					} else {
						console.error(`%c[FAIL] Test ${i+1}: ${verb.dictForm} (${form})`, 'color: red');
						console.error(`       - Expected: ${expected}`);
						console.error(`       - Got: ${result}`);
						failures++;
					}
				});

				if (failures === 0) {
					console.log("%c--- All tests passed! ---", 'color: green; font-weight: bold;');
				} else {
					console.error(`%c--- ${failures} test(s) failed. ---`, 'color: red; font-weight: bold;');
				}
			}
			// You can run the tests by typing `runConjugationTests()` in the console.
			// Making it available on the window object for easy access.
			window.runConjugationTests = runConjugationTests;
			window.conjugate = conjugate; // Make main conjugate function available for testing
		</script>
    </body>
</html>
